# 面向对象进阶

## 什么是多态？

> 同类型的对象，表现出的不同形态



## 多态的表现形式

`父类类型 对象名称 = 子类对象`



## 多态的前提？

+ 有继承/实现关系
+ 有父类引用指向子类对象
+ 有方法的重写



## 多态的好处？

使用父类型作为参数，可以接受所有子类对象，体现多态的扩展性与便利。



## 多态的优势与弊端

1. 多态的优势

   方法中，使用父类型作为参数，可以接收所有子类对象

2. 多态的弊端是什么？

   不能使用子类的特有功能

3. 引用数据类型的类型转换，有几种方式？

   > 自动类型转换           例如：Person p = new Student();
   >
   > 强制类型转换           例如：Student s = (Student)p;

4. 强制类型转换解决什么问题？

   + 可以转换成真正的子类类型，从而调用子类独有功能。
   + 转换类型与真实对象类型不一致会报错
   + 转换的时候用instanceof关键字进行判断



## 包和final

## 包

1. 什么是包？

   包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护。

   + 包名的规则：公司域名反写+包的作用，需要全部英文大写，见名知意。例如：com.zxycode.domain

2. 什么是全类名？

   包名 + 类名

3. 什么时候需要导包？什么时候不需要导包？

   + 使用同一个包中的类时，不需要导包。
   + 使用java.lang包中的类时，不需要导包。
   + 其他情况都需要导包
   + 如果同时使用两个包中的同名类，需要用全类名



## final

```
final修饰方法：
     表明该方法是最终方法，不能被重写
final修饰符：
     表明该类是最终类，不能被继承
final修饰变量：
     叫做常量，只能被赋值一次
```

**常量**

实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。

常量的命名规范：

+ 单个单词：全部大写
+ 多个单词：全部大写，单词之间用下划线隔开



细节：

- final修饰的变量是基本类型：那么变量存储的<span style="color:red;">数据值</span>不能发生改变。
- final修饰的变量是引用类型：那么变量存储的<span style="color:red;">地址值</span>不能发生改变，对象内部的可以改变。





**总结**

1. final修饰方法：最终方法，不能被重写
2. final修饰类：最终类，不能被继承
3. final修饰符变量：是常量，不能被修改
   + 基本数据类型：变量的值不能修改
   + 引用数据类型：地址值不能修改，内部的属性值可以修改





## 权限修饰符

+ 权限修饰符：是用来控制一个成员能够被访问的范围的。
+ 可以修饰成员变量，方法，构造方法，内部类。

### 权限修饰符分类

有四种作用范围由小到大（private < 空着不写(缺省/默认) < protected < public）

| 修饰符    | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下的无关类 |
| --------- | ---------- | ---------------- | -------------- | ---------------- |
| private   | √          |                  |                |                  |
| 空着不写  | √          | √                |                |                  |
| protected | √          | √                | √              |                  |
| public    | √          | √                | √              | √                |

``` java
/**

private 私房钱，只能自己用
protected  受保护的
默认     只能本包中用
public   公共的

*/
```



## 代码块

1. 代码块的分类：

   局部代码块，构造代码块，静态代码块

2. 局部代码块的作用

   提前结束变量的生命周期（已淘汰）

3. 构造代码块的作用

   抽取构造方法中的重复代码（不够灵活）

4. 静态代码块的作用

   数据的初始化（重点）





## 抽象类和抽象方法

### 总结

1. 抽象类的作用是什么样的？

   抽取共性时，无法确定方法体，就把方法定义为抽象的。

   强制让子类按照某种格式重写。

   抽象方法所有的类，必须是抽象类。

2. 抽象类和抽象方法的格式？

   public abstract 返回值类型  方法名（参数列表）；

   public abstract class 类名{}

3. 继承抽象类有哪些要注意？

   + 要么重写抽象类中的所有抽象方法
   + 要么是抽象类



## 接口



## 内部类

1. 什么是内部类？

   写在一个类里面的类就叫做内部类

2. 什么时候用到内部类？

   B类表示的事物是A类的一部分，且B单独存在没有意义。

   比如：汽车的发动机，ArrayList的迭代器，人的心脏等等。

### 成员内部类

1. 内部类的分类？

   成员内部类，静态内部类，局部内部类，匿名内部类。

2. 什么是成员内部类？

   写成员位置的，属于外部类的成员。

3. 获取成员内部类对象的两种方式？

   + 方式一：当成员内部被private修饰时。

     在外部类编写方法，对外提供内部类对象

   + 方式二：当成员内部被非私有修饰时，直接创建对象

     Outer.lnner oi = new Outer().new lnner();

4. 外部类成员变量和内部类成员变量重名时，在内部类如何访问？

   System.out.println(Outer.this.变量名);

### 静态内部类和局部外部类

#### 静态内部类

静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。

``` java
public class Car {  // 外部类
    String carName;
    int carAgr;
    int carColor;
    static class Engine {	// 静态内部类
        String engineName;
        int engineAge;
    }
}
```

+ 创建静态内部类对象的格式：外部类名.内部类名  对象名 = new 外部类名.内部类名();
+ 调用非静态方法的格式：先创建对象，用对象调用
+ 调用静态方法的格式：外部类名.内部类名.方法名();

**总结：**

1. 什么是静态内部类？

   静态内部类是一种特殊的成员内部类。

2. 直接创建静态内部类对象的方式？

   Outer.lnner oi = new Outer.lnner();

3. 如何调用静态内部类中的方法？

   非静态方法：先创建对象，用对象调用

   静态方法：外部类名.内部类名.方法名();

#### 局部内部类

1. 将内部类定义在方法里面就叫做局部内部类，类似与方法里面的局部变量。
2. 外界是无法直接使用，需要在方法内部创建对象使用。
3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。

