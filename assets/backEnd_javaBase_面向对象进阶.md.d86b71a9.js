import{_ as a,o as l,c as s,V as n}from"./chunks/framework.6038b03e.js";const C=JSON.parse('{"title":"面向对象进阶","description":"","frontmatter":{},"headers":[],"relativePath":"backEnd/javaBase/面向对象进阶.md","lastUpdated":null}'),t={name:"backEnd/javaBase/面向对象进阶.md"},p=n(`<h1 id="面向对象进阶" tabindex="-1">面向对象进阶 <a class="header-anchor" href="#面向对象进阶" aria-label="Permalink to &quot;面向对象进阶&quot;">​</a></h1><h2 id="什么是多态" tabindex="-1">什么是多态？ <a class="header-anchor" href="#什么是多态" aria-label="Permalink to &quot;什么是多态？&quot;">​</a></h2><blockquote><p>同类型的对象，表现出的不同形态</p></blockquote><h2 id="多态的表现形式" tabindex="-1">多态的表现形式 <a class="header-anchor" href="#多态的表现形式" aria-label="Permalink to &quot;多态的表现形式&quot;">​</a></h2><p><code>父类类型 对象名称 = 子类对象</code></p><h2 id="多态的前提" tabindex="-1">多态的前提？ <a class="header-anchor" href="#多态的前提" aria-label="Permalink to &quot;多态的前提？&quot;">​</a></h2><ul><li>有继承/实现关系</li><li>有父类引用指向子类对象</li><li>有方法的重写</li></ul><h2 id="多态的好处" tabindex="-1">多态的好处？ <a class="header-anchor" href="#多态的好处" aria-label="Permalink to &quot;多态的好处？&quot;">​</a></h2><p>使用父类型作为参数，可以接受所有子类对象，体现多态的扩展性与便利。</p><h2 id="多态的优势与弊端" tabindex="-1">多态的优势与弊端 <a class="header-anchor" href="#多态的优势与弊端" aria-label="Permalink to &quot;多态的优势与弊端&quot;">​</a></h2><ol><li><p>多态的优势</p><p>方法中，使用父类型作为参数，可以接收所有子类对象</p></li><li><p>多态的弊端是什么？</p><p>不能使用子类的特有功能</p></li><li><p>引用数据类型的类型转换，有几种方式？</p><blockquote><p>自动类型转换 例如：Person p = new Student();</p><p>强制类型转换 例如：Student s = (Student)p;</p></blockquote></li><li><p>强制类型转换解决什么问题？</p><ul><li>可以转换成真正的子类类型，从而调用子类独有功能。</li><li>转换类型与真实对象类型不一致会报错</li><li>转换的时候用instanceof关键字进行判断</li></ul></li></ol><h2 id="包和final" tabindex="-1">包和final <a class="header-anchor" href="#包和final" aria-label="Permalink to &quot;包和final&quot;">​</a></h2><h2 id="包" tabindex="-1">包 <a class="header-anchor" href="#包" aria-label="Permalink to &quot;包&quot;">​</a></h2><ol><li><p>什么是包？</p><p>包就是文件夹。用来管理各种不同功能的Java类，方便后期代码维护。</p><ul><li>包名的规则：公司域名反写+包的作用，需要全部英文大写，见名知意。例如：com.zxycode.domain</li></ul></li><li><p>什么是全类名？</p><p>包名 + 类名</p></li><li><p>什么时候需要导包？什么时候不需要导包？</p><ul><li>使用同一个包中的类时，不需要导包。</li><li>使用java.lang包中的类时，不需要导包。</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类，需要用全类名</li></ul></li></ol><h2 id="final" tabindex="-1">final <a class="header-anchor" href="#final" aria-label="Permalink to &quot;final&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">final修饰方法：</span></span>
<span class="line"><span style="color:#A6ACCD;">     表明该方法是最终方法，不能被重写</span></span>
<span class="line"><span style="color:#A6ACCD;">final修饰符：</span></span>
<span class="line"><span style="color:#A6ACCD;">     表明该类是最终类，不能被继承</span></span>
<span class="line"><span style="color:#A6ACCD;">final修饰变量：</span></span>
<span class="line"><span style="color:#A6ACCD;">     叫做常量，只能被赋值一次</span></span></code></pre></div><p><strong>常量</strong></p><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。</p><p>常量的命名规范：</p><ul><li>单个单词：全部大写</li><li>多个单词：全部大写，单词之间用下划线隔开</li></ul><p>细节：</p><ul><li>final修饰的变量是基本类型：那么变量存储的<span style="color:red;">数据值</span>不能发生改变。</li><li>final修饰的变量是引用类型：那么变量存储的<span style="color:red;">地址值</span>不能发生改变，对象内部的可以改变。</li></ul><p><strong>总结</strong></p><ol><li>final修饰方法：最终方法，不能被重写</li><li>final修饰类：最终类，不能被继承</li><li>final修饰符变量：是常量，不能被修改 <ul><li>基本数据类型：变量的值不能修改</li><li>引用数据类型：地址值不能修改，内部的属性值可以修改</li></ul></li></ol><h2 id="权限修饰符" tabindex="-1">权限修饰符 <a class="header-anchor" href="#权限修饰符" aria-label="Permalink to &quot;权限修饰符&quot;">​</a></h2><ul><li>权限修饰符：是用来控制一个成员能够被访问的范围的。</li><li>可以修饰成员变量，方法，构造方法，内部类。</li></ul><h3 id="权限修饰符分类" tabindex="-1">权限修饰符分类 <a class="header-anchor" href="#权限修饰符分类" aria-label="Permalink to &quot;权限修饰符分类&quot;">​</a></h3><p>有四种作用范围由小到大（private &lt; 空着不写(缺省/默认) &lt; protected &lt; public）</p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中其他类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>空着不写</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">private 私房钱，只能自己用</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">protected  受保护的</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">默认     只能本包中用</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">public   公共的</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">*/</span></span></code></pre></div><h2 id="代码块" tabindex="-1">代码块 <a class="header-anchor" href="#代码块" aria-label="Permalink to &quot;代码块&quot;">​</a></h2><ol><li><p>代码块的分类：</p><p>局部代码块，构造代码块，静态代码块</p></li><li><p>局部代码块的作用</p><p>提前结束变量的生命周期（已淘汰）</p></li><li><p>构造代码块的作用</p><p>抽取构造方法中的重复代码（不够灵活）</p></li><li><p>静态代码块的作用</p><p>数据的初始化（重点）</p></li></ol><h2 id="抽象类和抽象方法" tabindex="-1">抽象类和抽象方法 <a class="header-anchor" href="#抽象类和抽象方法" aria-label="Permalink to &quot;抽象类和抽象方法&quot;">​</a></h2><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ol><li><p>抽象类的作用是什么样的？</p><p>抽取共性时，无法确定方法体，就把方法定义为抽象的。</p><p>强制让子类按照某种格式重写。</p><p>抽象方法所有的类，必须是抽象类。</p></li><li><p>抽象类和抽象方法的格式？</p><p>public abstract 返回值类型 方法名（参数列表）；</p><p>public abstract class 类名{}</p></li><li><p>继承抽象类有哪些要注意？</p><ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ol><h2 id="接口" tabindex="-1">接口 <a class="header-anchor" href="#接口" aria-label="Permalink to &quot;接口&quot;">​</a></h2><h2 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h2><ol><li><p>什么是内部类？</p><p>写在一个类里面的类就叫做内部类</p></li><li><p>什么时候用到内部类？</p><p>B类表示的事物是A类的一部分，且B单独存在没有意义。</p><p>比如：汽车的发动机，ArrayList的迭代器，人的心脏等等。</p></li></ol><h3 id="成员内部类" tabindex="-1">成员内部类 <a class="header-anchor" href="#成员内部类" aria-label="Permalink to &quot;成员内部类&quot;">​</a></h3><ol><li><p>内部类的分类？</p><p>成员内部类，静态内部类，局部内部类，匿名内部类。</p></li><li><p>什么是成员内部类？</p><p>写成员位置的，属于外部类的成员。</p></li><li><p>获取成员内部类对象的两种方式？</p><ul><li><p>方式一：当成员内部被private修饰时。</p><p>在外部类编写方法，对外提供内部类对象</p></li><li><p>方式二：当成员内部被非私有修饰时，直接创建对象</p><p>Outer.lnner oi = new Outer().new lnner();</p></li></ul></li><li><p>外部类成员变量和内部类成员变量重名时，在内部类如何访问？</p><p>System.out.println(Outer.this.变量名);</p></li></ol><h3 id="静态内部类和局部外部类" tabindex="-1">静态内部类和局部外部类 <a class="header-anchor" href="#静态内部类和局部外部类" aria-label="Permalink to &quot;静态内部类和局部外部类&quot;">​</a></h3><h4 id="静态内部类" tabindex="-1">静态内部类 <a class="header-anchor" href="#静态内部类" aria-label="Permalink to &quot;静态内部类&quot;">​</a></h4><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Car</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 外部类</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> carName</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> carAgr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> carColor</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Engine</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">	</span><span style="color:#676E95;font-style:italic;">// 静态内部类</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> engineName</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> engineAge</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ul><li>创建静态内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();</li><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><strong>总结：</strong></p><ol><li><p>什么是静态内部类？</p><p>静态内部类是一种特殊的成员内部类。</p></li><li><p>直接创建静态内部类对象的方式？</p><p>Outer.lnner oi = new Outer.lnner();</p></li><li><p>如何调用静态内部类中的方法？</p><p>非静态方法：先创建对象，用对象调用</p><p>静态方法：外部类名.内部类名.方法名();</p></li></ol><h4 id="局部内部类" tabindex="-1">局部内部类 <a class="header-anchor" href="#局部内部类" aria-label="Permalink to &quot;局部内部类&quot;">​</a></h4><ol><li>将内部类定义在方法里面就叫做局部内部类，类似与方法里面的局部变量。</li><li>外界是无法直接使用，需要在方法内部创建对象使用。</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</li></ol>`,49),e=[p];function i(o,r,c,d,h,u){return l(),s("div",null,e)}const A=a(t,[["render",i]]);export{C as __pageData,A as default};
