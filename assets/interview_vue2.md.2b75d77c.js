import{_ as a,o as e,c as s,V as n}from"./chunks/framework.6038b03e.js";const m=JSON.parse('{"title":"vue2","description":"","frontmatter":{"title":"vue2"},"headers":[],"relativePath":"interview/vue2.md","lastUpdated":1686205870000}'),o={name:"interview/vue2.md"},l=n(`<h1 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h1><h2 id="vue-兼容到-ie-几" tabindex="-1">vue 兼容到 ie 几？ <a class="header-anchor" href="#vue-兼容到-ie-几" aria-label="Permalink to &quot;vue 兼容到 ie 几？&quot;">​</a></h2><p>兼容IE8以上版本，不兼容IE8及以下版本。<a href="https://www.php.cn/vuejs/483396.html" target="_blank" rel="noreferrer">链接地址</a></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">原因：</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">、IE8及一下版本不支持“Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">defineProperty”方法，但该方法是vue实现响应式的所必须的</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">、Vue需要Promise的支持，而IE8不支持Promsie。</span></span></code></pre></div><h2 id="vue项目启动顺序" tabindex="-1">vue项目启动顺序 <a class="header-anchor" href="#vue项目启动顺序" aria-label="Permalink to &quot;vue项目启动顺序&quot;">​</a></h2><blockquote><p><a href="https://www.jianshu.com/p/436ec9ac4bbe" target="_blank" rel="noreferrer">https://www.jianshu.com/p/436ec9ac4bbe</a></p></blockquote><ol><li><p>vue3启动时，会先加载<code>public/index.html</code>文件，其中只要有：主要是提供一个<code>div</code> 给<code>vue</code> 挂载。</p><p><img src="https://img-blog.csdnimg.cn/ea1c5fba6b6643dba820781f02192ca1.png" alt=""></p></li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ol start="2"><li>然后，会加载main.js文件：</li></ol><p><code>main.js</code>中，引入了<code>Vue</code>、<code>App.vue</code>和<code>Router</code>模块，创建了一个<code>Vue</code>对象，并把<code>App.vue</code>的模板内容挂载到<code>index.html</code>的<code>id</code>为<code>app</code>的div标签下，并绑定了一个路由配置。</p><p><img src="https://upload-images.jianshu.io/upload_images/15033832-7977bbbed712c0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/659/format/webp" alt=""></p><ol start="3"><li>App.vue</li></ol><p>上面 <code>main.js</code>把 <code>App.vue</code> 模板的内容，放置在了<code>index.html</code> 的 <code>div</code> 标签下面。查看 <code>App.vue</code>的内容我们看到，这个页面的内容由一个 <code>logo</code>和一个待放置内容的<code>router-view</code>，<code>router-view</code> 的内容将由<code>router</code> 配置决定。</p><img src="https://upload-images.jianshu.io/upload_images/15033832-f60f3dc489017ea0.png?imageMogr2/auto-orient/strip|imageView2/2/w/539/format/webp"><ol start="4"><li>router / index.js</li></ol><p>查看<code>route</code> 目录下的<code>index.js</code>，我们发现这里配置了一个路由， 在访问路径<code>/</code> 的时候， 会把 <code>HelloWorld</code> 模板的内容放置到上面的<code>router-view</code>中。</p><p><img src="https://upload-images.jianshu.io/upload_images/15033832-88e27b450ec0305b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/473/format/webp" alt=""></p><ol start="5"><li>HelloWorld.vue</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/15033832-1d44abf510fe8929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp" alt=""></p><ol start="6"><li>页面组成</li></ol><p>​ 所以，页面关系组成是 index.html 包含 App.vue，App.vue 包含 HelloWorld.vue</p><p><img src="https://upload-images.jianshu.io/upload_images/15033832-1d44abf510fe8929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp" alt=""></p><h2 id="说一下-vue生命周期" tabindex="-1">说一下 Vue生命周期 <a class="header-anchor" href="#说一下-vue生命周期" aria-label="Permalink to &quot;说一下 Vue生命周期&quot;">​</a></h2><h2 id="说一下-组件通信" tabindex="-1">说一下 组件通信 <a class="header-anchor" href="#说一下-组件通信" aria-label="Permalink to &quot;说一下 组件通信&quot;">​</a></h2><h2 id="说一下-vuex" tabindex="-1">说一下 Vuex <a class="header-anchor" href="#说一下-vuex" aria-label="Permalink to &quot;说一下 Vuex&quot;">​</a></h2><h2 id="说一下双向数据绑定的原理" tabindex="-1">说一下双向数据绑定的原理 <a class="header-anchor" href="#说一下双向数据绑定的原理" aria-label="Permalink to &quot;说一下双向数据绑定的原理&quot;">​</a></h2><h2 id="知道哪些vue指令" tabindex="-1">知道哪些vue指令 <a class="header-anchor" href="#知道哪些vue指令" aria-label="Permalink to &quot;知道哪些vue指令&quot;">​</a></h2><h2 id="说一下自定义指令" tabindex="-1">说一下自定义指令 <a class="header-anchor" href="#说一下自定义指令" aria-label="Permalink to &quot;说一下自定义指令&quot;">​</a></h2><h2 id="说一下路由传参" tabindex="-1">说一下路由传参 <a class="header-anchor" href="#说一下路由传参" aria-label="Permalink to &quot;说一下路由传参&quot;">​</a></h2><h2 id="生命周期父子组件执行顺序" tabindex="-1">生命周期父子组件执行顺序 <a class="header-anchor" href="#生命周期父子组件执行顺序" aria-label="Permalink to &quot;生命周期父子组件执行顺序&quot;">​</a></h2><h2 id="过滤器有没有用过-什么场景" tabindex="-1">过滤器有没有用过（什么场景） <a class="header-anchor" href="#过滤器有没有用过-什么场景" aria-label="Permalink to &quot;过滤器有没有用过（什么场景）&quot;">​</a></h2><h2 id="用第三方库报错怎么办" tabindex="-1">用第三方库报错怎么办 <a class="header-anchor" href="#用第三方库报错怎么办" aria-label="Permalink to &quot;用第三方库报错怎么办&quot;">​</a></h2><h2 id="vmodel-是谁的语法糖" tabindex="-1">vmodel 是谁的语法糖 <a class="header-anchor" href="#vmodel-是谁的语法糖" aria-label="Permalink to &quot;vmodel 是谁的语法糖&quot;">​</a></h2><h2 id="query-和-params-区别" tabindex="-1">query 和 params 区别 <a class="header-anchor" href="#query-和-params-区别" aria-label="Permalink to &quot;query 和 params 区别&quot;">​</a></h2><h2 id="vue怎么获取dom" tabindex="-1">vue怎么获取dom <a class="header-anchor" href="#vue怎么获取dom" aria-label="Permalink to &quot;vue怎么获取dom&quot;">​</a></h2><h2 id="vue中的key有什么作用-key内部的原理" tabindex="-1">vue中的key有什么作用？（key内部的原理） <a class="header-anchor" href="#vue中的key有什么作用-key内部的原理" aria-label="Permalink to &quot;vue中的key有什么作用？（key内部的原理）&quot;">​</a></h2><blockquote><p>1、虚拟DOM中key的作用：</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">key是虚拟DOM对象的标识，当状态中的数据发生变化时，vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">、对比规则：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> 		（</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">）旧虚拟DOM中找到了与新虚拟DOM相同的key：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> 若虚拟DOM中内容没变，直接使用之前的真实DOM！</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中之前的真实DOM</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">      	（</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">）旧虚拟DOM中未找到与新虚拟DOM相同的key</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">           				创建新的真实DOM，随后渲染到页面</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">、用index作为key可能会引发的问题：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> 若对数据进行：逆序添加、逆序删除等破坏顺序操作：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">     	会产生没有必要的真实DOM更新 </span><span style="color:#89DDFF;">==&gt;</span><span style="color:#A6ACCD;"> 界面效果没问题，但效率低</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> 如果结构中还包含输入类的DOM：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">     	会产生错误DOM更新 </span><span style="color:#89DDFF;">==&gt;</span><span style="color:#A6ACCD;"> 界面有问题</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">、开发中如何选择key？</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;"> 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;"> 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染泪飙用于展示，使用index作为key是没有问题的</span></span></code></pre></div><h2 id="为什么组件data必须是函数" tabindex="-1">为什么组件data必须是函数？ <a class="header-anchor" href="#为什么组件data必须是函数" aria-label="Permalink to &quot;为什么组件data必须是函数？&quot;">​</a></h2><p>如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据，而单纯的写成对象形式，就使得所有组件实例共用一份data，就会造成一个变了全都会变的结果。</p><p>所以说vue组件的data必须是函数，这都是js的特性带来的，跟vue本身设计无关。</p><p>js本身的面向对象编程也是基于原型链和构造函数，应该会注意原型链上添加一般都会一个函数方法而不会去添加一个对象了。</p>`,42),p=[l];function t(r,c,i,d,u,h){return e(),s("div",null,p)}const y=a(o,[["render",t]]);export{m as __pageData,y as default};
